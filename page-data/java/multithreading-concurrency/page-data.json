{"componentChunkName":"component---src-templates-notes-js","path":"/java/multithreading-concurrency","result":{"data":{"markdownRemark":{"html":"<h1>Multithreading Concurrency</h1>\n<h2>Thread</h2>\n<h3>Thread lifecycle &#x26; state</h3>\n<ul>\n<li><code class=\"language-text\">NEW</code>: created but not yet started execution.</li>\n<li><code class=\"language-text\">RUNNABLE</code>: either ready to run or currently running.</li>\n<li><code class=\"language-text\">BLOCKED</code>: A thread in the blocked state is waiting for a monitor lock, entering/re-entering synchronized block.</li>\n<li><code class=\"language-text\">WAITING</code>: waits for another thread on a condition. When this condition is fulfilled, the scheduler is notified and the waiting thread is moved to runnable state.</li>\n<li><code class=\"language-text\">TIMED_WAITING</code>: waiting for some thread to perform some action for a specific period</li>\n<li><code class=\"language-text\">TERMINATED</code>: either exists normally or due to error</li>\n</ul>\n<h3>Java Threading Model</h3>\n<h2><code class=\"language-text\">CAS</code></h2>\n<p>Compare-and-swap (CAS) is a single atomic operation (in assembly level), to compare the value at given memory location with an expected value, if and only if the current memory value is the same as the expected value, it set the memory value to a new value. For example, in linux x86, the operation can be performed by <code class=\"language-text\">CMPXCHG</code>. If the value doesn't match, the write will fail.</p>\n<p>In java, the implementation of the <code class=\"language-text\">Atomic</code> types such as <code class=\"language-text\">AtomicInteger</code> relies on Compare-and-swap mechanism and <code class=\"language-text\">volatile</code> variable. It uses a loop a keep testing the update with <code class=\"language-text\">CAS</code> until it succeed. It is much like a spin-lock.</p>\n<p>CAS is an optimistic locking mechanism. Note in multi-processor system, the atomicity that <code class=\"language-text\">CMPXCHG</code> provides is not enough, we also need to lock the memory bus.</p>\n<h3>ABA problem</h3>\n<p>CAS need to check if the value has changed from the expected value.</p>\n<p>Consider a scenario where a value is updated by another thread from <code class=\"language-text\">A</code> to <code class=\"language-text\">B</code> then back to <code class=\"language-text\">A</code>. When we use CAS to test the value, we would get the conclusion that the value has not changed, which is incorrect.</p>\n<p>One solution to ABA problem is to use tagged reference (similar idea to multi-version version control in InnoDB). Each time the value is modified, we increment the tag value.</p>\n<p>Java use this solution, see <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicStampedReference.html\"><code class=\"language-text\">java.util.concurrent.atomic.AtomicStampedReference</code></a>.</p>\n<h2><code class=\"language-text\">synchronized</code> keyword</h2>\n<p>Ensure atomicity and visibility.Every java object can implicitly act as a lock for purpose of synchronization using <code class=\"language-text\">synchronized</code> keyword. These built in locks are called <em>intrinsic locks</em> or <em>monitor locks</em>. Using <code class=\"language-text\">synchronized</code> is the only way to acquire an intrinsic locks. Intrinsic locks act as mutexes (mutual exclusion locks), which means at most one thread may own the lock.</p>\n<p>Since JDK 6, the synchronized lock has been optimized to be less heavy.</p>\n<h3>JDK 1.6 optimizations</h3>\n<ul>\n<li>\n<p><strong>Adaptive spinning</strong></p>\n<ul>\n<li>This is an optimization to employ a 2-phase spin-then-block strategy. Threads contending locks initially attempt to spin for a few times before blocking. It uses metrics to determine whether to spin or block in the future adaptively.</li>\n</ul>\n</li>\n<li>\n<p><strong>Llock coarsening</strong></p>\n<ul>\n<li>reduces the amount of synchronization work (lock, unlock) by enlarging an existing synchronized region.</li>\n</ul>\n</li>\n<li>\n<p><strong>Biased locking</strong></p>\n<ul>\n<li>Static analysis to decide if locking is required. If it is not possible to have shared access, the lock can be cancelled</li>\n</ul>\n</li>\n</ul>\n<h3>Class level lock</h3>\n<p><code class=\"language-text\">synchronized</code> can only be used with methods or code blocks, but we can use it to implement locking at various levels.</p>\n<p>Below code examples shows implementation of a class level lock, which locks access across all instances. Class level lock should be used to keep static data thread safe.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SomeClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// thread safe code</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>or put <code class=\"language-text\">synchronized</code> keyword on static method</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// must be a static method</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// thread safe code</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>or use a static varialbe as lock:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> LOCK <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>LOCK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// thread safe code</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Object level lock</h3>\n<p>Object level lock is mechanism when we want to synchronize access such that only one thread can execute the code block on a given instance at anytime. This should always be done to make instance level data thread safe.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// only non-static method</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doThing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>or</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doThing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// only non-static code blocks</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// thread safe code</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>or use an instance variable as lock:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doThing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// thread safe code</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2><code class=\"language-text\">volatile</code> keywoard</h2>\n<p><code class=\"language-text\">volatile</code> is used to ensure visibility, when a field is declared <code class=\"language-text\">volatile</code>, the java memory model ensures that all threads see a consistent value. change from one thread is visible in another. Doesn't ensure atomicity.</p>\n<p>Using <code class=\"language-text\">volatile</code> is lighter than <code class=\"language-text\">synchronized</code>, but of course it's usecase is more limited.</p>\n<p>Use cases:</p>\n<ul>\n<li>when you only need to get the value or set the value, it is not suitable for getAndOperate kind of operation.</li>\n</ul>\n<h3>Memory barrier</h3>\n<p>JVM add a barrier instruction when reading/writing <code class=\"language-text\">volatile</code>. Memory barrier is a CPU instruction that ensures the ordering of instruction and visibility.</p>\n<h2><code class=\"language-text\">Atomic types</code></h2>\n<p>atomic types implement atomicity with CAS and <code class=\"language-text\">volatile</code>.</p>\n<h2>Wait and notify</h2>\n<p><code class=\"language-text\">wait()</code>, <code class=\"language-text\">notify()</code> and <code class=\"language-text\">notifyAll</code> are isntance methods used for thread synchronization. They are defined on <code class=\"language-text\">java.lang.Object</code>, so callable for all object instances.</p>\n<p>can only be called in a synchronized block. It releases the lock on the object so that another thread can jump in an acquire the lock.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">wait()</code>:</p>\n<ul>\n<li><code class=\"language-text\">wait</code> method can only be called when it owns the object's monitor (i.e. in a <code class=\"language-text\">synchronized</code> block/function). Calling <code class=\"language-text\">wait()</code> causes current thread to wait indefinitely until another thread invokes <code class=\"language-text\">notify</code> for this object or invokes <code class=\"language-text\">notifyAll</code>.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">wait(long timeout)</code>:</p>\n<ul>\n<li>we can specify a timeout after which thread will be woken up automatically. A thread can be woken up before reaching the timeout using notify() or notifyAll().</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">wait(long timeout, int nanos)</code>:</p>\n<ul>\n<li>same with higher precision.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">notify()</code>:</p>\n<ul>\n<li>used for waking up <strong>one thread</strong> that is waiting for the access to this object's monitor. The choice of exactly which thread to wake is non-deterministic.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">notifyAll</code>:</p>\n<ul>\n<li>used for waking up <strong>all threads</strong> that are waiting for the access to this object's monitor.</li>\n</ul>\n</li>\n</ul>\n<p>Normally we do additional time of condition check after a thread wakes up, to make sure the execution condition is satisfied.</p>\n<h3>Difference: wait and sleep</h3>\n<ul>\n<li>wait is used for synchronization, while sleep is not. sleep is more for controlling of execution time</li>\n<li>wait release lock, while sleep doesn't (when inside synchronized block of course)</li>\n</ul>\n<h2>Locks</h2>\n<p>A lock is a more flexible and sophisticated thread synchronization mechanism than <code class=\"language-text\">synchronized</code> block. The <em>Lock interface</em> has been around since JDK 1.5. It's defined under the <code class=\"language-text\">java.util.concurrent.locks</code> package.</p>\n<p>Difference betwen <code class=\"language-text\">synchronized</code></p>\n<ul>\n<li>Lock is more flexible. <code class=\"language-text\">synchronized</code> is fully contained within one method. but Lock API's <code class=\"language-text\">lock()</code> and <code class=\"language-text\">unlock()</code> operation can be separated in different methods.</li>\n<li><code class=\"language-text\">synchronized</code> block doesn't support fairness. But we can achieve fairness with the Lock API.</li>\n<li><code class=\"language-text\">tryLock</code></li>\n</ul>\n<h3>ReentrantLock</h3>\n<h2>Task Execution</h2>\n<h3>Executor Framework</h3>\n<h2>Why Thread pool</h2>\n<ul>\n<li>lower resource consumption. Reusing thread to lower the cost of creating and destroy threads.</li>\n<li>faster response time, because we save the cost of creating thread.</li>\n<li>centralized management of thread. As thread is a limited resource, creating threads without proper management can lower system stability.</li>\n</ul>\n<h2>Types of thread pool</h2>\n<p>provided by executor framework, we have 4 types:</p>\n<ul>\n<li>\n<p><code class=\"language-text\">FixedThreadPool</code></p>\n<ul>\n<li>always fixed size</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">SingleThreadExecutor</code></p>\n<ul>\n<li>only 1 thread</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">CachedThreadPool</code></p>\n<ul>\n<li>dynamic size</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">ScheduledThreadPollExecutor</code></p>\n<ul>\n<li>for delayed execution, or periodic execution</li>\n</ul>\n</li>\n</ul>\n<h2>ThreadPoolExecutor</h2>\n<ul>\n<li>core size</li>\n<li>maximum size</li>\n<li>keep alive time</li>\n</ul>\n<h3>Life cycle and state transitioning</h3>\n<ul>\n<li><code class=\"language-text\">RUNNING</code>: accept new task and process queued tasks</li>\n<li><code class=\"language-text\">SHUTDOWN</code>: don't accept new tasks, but process queued tasks</li>\n<li><code class=\"language-text\">STOP</code>: don't accept or process any tasks, also interrupt in-progress tasks.</li>\n<li><code class=\"language-text\">TIDYING</code>: all tasks have terminated, workerCount is zero, the thread transitioning to state <code class=\"language-text\">TIDYING</code> and run the <code class=\"language-text\">terminated()</code> hook</li>\n<li><code class=\"language-text\">TERMINATED</code>: <code class=\"language-text\">terminated()</code> completed</li>\n</ul>\n<h3>Rejection Policy</h3>\n<p>When does a rejection happen?</p>\n<p>1.</p>\n<ol start=\"2\">\n<li>The work queue is full, and creating new thread also fails (resource saturated).</li>\n</ol>\n<p><code class=\"language-text\">RejectedExecutorHandler</code> implementations</p>\n<ul>\n<li><code class=\"language-text\">AbortPolicy</code>: throws <code class=\"language-text\">RejectedExecutionException</code></li>\n<li><code class=\"language-text\">DiscardPolicy</code>: silently discard rejected task, it's a no-op implementation</li>\n<li><code class=\"language-text\">DiscardOldestPolicy</code>: discards the oldest unhandled task, and retry the current rejected task</li>\n<li><code class=\"language-text\">CallerRunsPolicy</code>: execute the rejected task in caller thread</li>\n</ul>","frontmatter":{"title":"Multi-threading and Concurrency in Java"},"parent":{"__typename":"File","modifiedTime":"2021-10-26T14:41:02.019Z"}}},"pageContext":{}}}