{"componentChunkName":"component---src-templates-notes-js","path":"/java/jmm","result":{"data":{"markdownRemark":{"html":"<h1>Memory Model &#x26; Management</h1>\n<h2>Runtime data areas</h2>\n<ul>\n<li>Method area (PermaGen)</li>\n<li>\n<p>Heap</p>\n<ul>\n<li>Young Generation</li>\n<li>Eden space</li>\n<li>Survivor space S0, S1</li>\n<li>Tenured space</li>\n</ul>\n</li>\n<li>\n<p>Per thread data</p>\n<ul>\n<li>Program counter</li>\n<li>JVM stack</li>\n<li>Native method stack</li>\n</ul>\n</li>\n</ul>\n<h3>Stack</h3>\n<p>Each thread has it's own stack, and can't access stack of another thread.</p>\n<h3>Heap</h3>\n<p>Where the actual objects. Segregated into multiple areas.</p>\n<h2>Reference Types</h2>\n<h3>Strong Reference</h3>\n<p>The common reference types. Strongly referenced objects are not eligible for GC.</p>\n<h3>Soft Reference</h3>\n<p>A softly referenced object won't be GC'd unless JVM absolutely needs memory.</p>\n<p>They are good foundation for cache.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">></span></span> ref <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Weak Reference</h3>\n<p>Similar to soft reference in a sense that it can be GC'd. However, the main difference is that weak references are GC'd eagerly.</p>\n<p>it can be used for caching (although strict eviction), see for example <code class=\"language-text\">WeakHashMap&lt;K, V&gt;</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">></span></span> weakRef <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// then later you can get the actual object, you may get</span>\n<span class=\"token comment\">// null since weak reference isn't strong enough to prevent</span>\n<span class=\"token comment\">// garbage collection.</span>\nweakRef<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Phantom Reference</h3>\n<p>The phantom reference is added to the reference queue after the finalize method of its referent is executed.</p>\n<h2>Garbage Collection</h2>\n<p>important idea first:</p>\n<ul>\n<li>The process is triggered automaitcally by Java. It's upto the JVM when and whether or not to do it.</li>\n<li>It's an expensive process. When it runs, all threads in the application are paused.</li>\n<li>calling <code class=\"language-text\">System.gc()</code> does not gurantee a GC, again, it's up to JVM.</li>\n</ul>\n<p>GC is implemented in a \"Mark and Sweep\" way. Java analyzes the references from the stack and \"mark\" the objects to keep, then \"sweep\" the unused.</p>\n<p>Young Generation</p>\n<ul>\n<li>Eden Space</li>\n<li>Survivor Space - S0 and S1\nTenured Space (Old Generation)\nMetaspace (PermGen before Java8)\nCode Cache</li>\n</ul>\n<h3>Garbage collection types</h3>\n<h4>Minor GC</h4>\n<p>collecting garbage in young generation.</p>\n<ul>\n<li>always triggered when JVM is unable to allocate space for new Object.</li>\n<li>minor GCs also trigger stop-the-world pauses.</li>\n</ul>\n<h4>Major GC</h4>\n<p>cleaning tenured space</p>\n<h4>Full GC</h4>\n<p>entire heap</p>\n<h3>Types of Garbage Collectors</h3>\n<p>1.<strong>Serial GC</strong> -</p>\n<p>2.<strong>Parallel GC</strong> -</p>\n<p>3.<strong>Mostyl concurent GC</strong> -</p>\n<p>3.1.<strong>Garbage First</strong> -\nhigh throughput with a reasonable application pause time</p>\n<p>3.1.<strong>Concurrent Mark Sweep</strong> - Deperacated as of JDK 9</p>\n<h2>Technics for Debugging Memory</h2>\n<ul>\n<li>Use VisualVM to make a heap dump, so you can analyze, per class, how much memory it occupies.</li>\n<li>If Java application crashese with <code class=\"language-text\">OutOfMemoryError</code>, run the process with <code class=\"language-text\">-XX:HeapDumpOnOutOfMemory</code> which create a heap dump file when the error happens next time.</li>\n<li>Use <code class=\"language-text\">-verbose:gc</code> option to get the garbage collection output for each GC.</li>\n</ul>","frontmatter":{"title":"Java Memory Model (JMM)"},"parent":{"__typename":"File","modifiedTime":"2021-10-26T14:41:02.019Z"}}},"pageContext":{}}}