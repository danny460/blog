{"componentChunkName":"component---src-templates-notes-js","path":"/operating-system/inter-process-communication","result":{"data":{"markdownRemark":{"html":"<h2>Race Condition and Critical Regions</h2>\n<p><strong>Race condition</strong> can happen when two or more processes write or read some shared data. To avoid race condition, we need to enforce <strong>mutual exclusion</strong> on access to shared data.</p>\n<p>The <span class=\"u\">part of program</span> where the shared memory is accessed is called the <strong>critical region</strong>.</p>\n<h2>Achieving Mutual Exclusion</h2>\n<p>There are many apporches to achieve mutual exclu-\nsion, so that while one process is busy updating shared memory in its critical region, no other process will enter. There are different hardware and software approaches, some employee a technique called <strong>busy waiting</strong>, where you would continuously test for some condition to become true before entering critical region.</p>\n<h3>(1) <strong>Disabling Interrupts</strong></h3>\n<p>This is the simplest solution, to turn off interrupt on CPU will switching to other process in the middle of critical regions. But It is generally unattractive because the waiting time for user process can be arbitrary, and achieves low concurrency. Also it does not work for multiprocessor systems, because disabling interrupt for one CPU does not prevent others from running processes. However, it is convinient for the kernel to disable interrupts for some instructions.</p>\n<p>In conclusion this can be useful within the operating system itself, but not for general user processes.</p>\n<h3>(2) <strong>Software Approach</strong></h3>\n<p>By opting a software approach, the programmer need to code in a way where access to shared data is safe. Examples are Dekker's algorithm and Peterson's algorithm, which uses the idea of taking turns and lock variables.</p>\n<p>Below snippet shows Peterson's algorithm, before using shared variables, each process call the <code class=\"language-text\">enter_region</code> method, and after leaving the critical region, call <code class=\"language-text\">leave_region</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FALSE 0</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> TRUE 1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> N 2 </span><span class=\"token comment\">// number of processes</span>\n\n<span class=\"token keyword\">int</span> turn<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// whose turn is it?</span>\n<span class=\"token keyword\">int</span> interested<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// all values initially 0 (FALSE)</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">enter_region</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> process<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\">// process is 0 or 1</span>\n    <span class=\"token keyword\">int</span> other <span class=\"token operator\">=</span> <span class=\"token number\">1</span> âˆ’ process<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// the other process</span>\n    interested<span class=\"token punctuation\">[</span>process<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// show that you are interested</span>\n    turn <span class=\"token operator\">=</span> process<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// set flag</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>turn <span class=\"token operator\">==</span> process <span class=\"token operator\">&amp;&amp;</span> interested<span class=\"token punctuation\">[</span>other<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null statement</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">leave_region</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> process<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    interested<span class=\"token punctuation\">[</span>process<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>(3) <strong><code class=\"language-text\">TSL</code> and <code class=\"language-text\">XCHG</code></strong></h3>\n<p>the <code class=\"language-text\">TSL</code> (or <strong>Test, and Set Lock</strong>) instruction reads the content of memory word <code class=\"language-text\">lock</code> and stores a non-zero value at the that address. <code class=\"language-text\">TSL</code> operation is indivisible (<strong>atomic</strong>), it will lock the memory bus and prohibit other CPU from accessing the memory word until its done.</p>\n<p><code class=\"language-text\">TSL</code> can be used to implement the lock variable, and with busy waiting we can achieve mutual exclusion. A lock that uses busy waiting is called a <strong>spin lock</strong></p>\n<p>pseudo assembly code showing how it works:</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">enter_region:\n    TSL REGISTER,LOCK   | copy value to register and set lock to 1\n    CMP REGISTER,#0     | compare lock value with 0\n    JNE enter_region    | infinite loop if non-zero, busy waiting\n    RET                 | else return (to continue to critical region)\n\nleave_region:\n    MOVE LOCK,#0        | set lock back to 0\n    RET</code></pre></div>\n<p><code class=\"language-text\">XCHG</code> instruction is an alternative to <code class=\"language-text\">TSL</code>, which exchange content of two memory location, <span class=\"u\">atomically</span>. Intel x86 CPU uses XCHG for low-level synchronization.</p>\n<h3>(4) <strong>Semaphore</strong></h3>\n<p>Semaphores uses sleep/wake-up instead of busy waiting. A semaphore need to be initialized with a value, and it has 2 <strong>atomic</strong> operations:</p>\n<ul>\n<li><strong>down</strong>: checks if value > 0. If so, decrement value and continue, else put process to sleep, without completing down.</li>\n<li><strong>up</strong>: increment value, and choose a sleeping process (if any) to wakeup and complete its down operation.</li>\n</ul>\n<p>Semaphore can be use as mutex, or for synchronization.</p>\n<h4>Mutexes</h4>\n<h3>(5) <strong>Monitor</strong></h3>\n<p>With semaphores/mutexes, developer must be very careful or else it could cause subtle errors. Monitors are here to provide a easier and less error-prone way to work with synchronization.</p>\n<p>Monitor is a programming language concept, and its special behaviors have to be implemented by the language's compiler.</p>\n<p>A monitor is a collection of procedures, variables and data structures that are grouped together in a special kind of module. Proccess can call the procedures but they cannot directly access the internal data. <span class=\"u\">Monitors have an important property that, there can be only one process active in the monitor at any instant.</span></p>\n<p>typically when a process calls a monitor procedure, the compiler will add the check to see if any other process is currently active within the monitor. If so, the calling process will be suspended until the other process left. Else the calling process is allowed to enter.</p>\n<p>Additionally we use <strong>condition variables</strong> and <code class=\"language-text\">wait</code>/<code class=\"language-text\">signal</code> operation, to suspend and wakeup processes. To aviod having 2 active processes when wake-up(signal), there are a few solutions:</p>\n<ul>\n<li>Hansen: enforce the rule that whenever a process does a <code class=\"language-text\">signal</code>, it must exit immediately.</li>\n<li>Hoare: if P does signal and wake-up Q, suspend P and let newly awaken Q run.</li>\n<li>MESA: if P signal, P continue to run and only allow the waiting process to run when P exits. (additional condition check is required after the waiting process starts running, because condition could change).</li>\n</ul>\n<h4>Application: Java</h4>\n<p>In Java, we can use the <code class=\"language-text\">synchronized</code> keyword with <code class=\"language-text\">wait</code>/<code class=\"language-text\">notify</code> to construct the monitor.</p>\n<h3>(6) Send/Recieve</h3>\n<p>Message passing allows passing of more complex message, it uses 2 primitives <code class=\"language-text\">send</code> and <code class=\"language-text\">recieve</code>.</p>\n<h3>(7) Barriers</h3>\n<p>Barrier primitive is a way to synchronize multiple process in phases. Barrier ensures that no process can advance to the next phase util all processes complete the current phase.</p>\n<h2>Concurrency in POSIX Threads</h2>\n<p>POSIX Threads (usually pthreads), is an execution model independent from language.</p>\n<p>pthread<em>mutex</em>init\npthread<em>mutex</em>init\npthread<em>mutex</em>init\npthread<em>mutex</em>init\npthread<em>mutex</em>init</p>\n<p>pthread<em>cond</em>init\npthread<em>cond</em>init\npthread<em>cond</em>init\npthread<em>cond</em>init\npthread<em>cond</em>init</p>\n<h2>IPC Mechanism in Linux</h2>","frontmatter":{"title":"Inter-process Communication"},"parent":{"__typename":"File","modifiedTime":"2021-10-26T14:41:02.023Z"}}},"pageContext":{}}}