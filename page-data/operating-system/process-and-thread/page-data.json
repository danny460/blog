{"componentChunkName":"component---src-templates-notes-js","path":"/operating-system/process-and-thread","result":{"data":{"markdownRemark":{"html":"<p>A process is just an instance of an executing program, including the current\nvalues of the program counter, registers and variables.</p>\n<p>Processes that stay in the background to handle some activity such as email are called <strong>daemons</strong>.</p>\n<blockquote>\n<p>In linux, the <code class=\"language-text\">ps</code> program can be used to list hte running processes.</p>\n</blockquote>\n<h2>Process Creation</h2>\n<p>Technically, in all these cases, a new process is created by having an existing\nprocess execute a process creation system call. That process may be a running user\nprocess, a system process invoked from the keyboard or mouse, or a batch-manager\nprocess. What that process does is execute a system call to create the new\nprocess. This system call tells the operating system to create a new process and indicates, directly or indirectly, which program to run in it.</p>\n<blockquote>\n<p>In linux, there is only one system call to create a new process: <code class=\"language-text\">fork</code>. This call create an exact clone of the calling process. After the fork, the tow processes, have the same memory image, same environment strings, same open files. Usually, the child process then execute <code class=\"language-text\">execve</code> or similar system call to change its memory image and run a new program.</p>\n<p>Why take the two step approach? The reason is to allow the child to manipulate its file descriptors after the <code class=\"language-text\">fork</code> but before teh <code class=\"language-text\">execve</code> in order to accomplish redirection of <code class=\"language-text\">stdin</code>, <code class=\"language-text\">stdout</code> and <code class=\"language-text\">stderr</code> (???????????????????)</p>\n</blockquote>\n<h2>Process Termination</h2>\n<ol>\n<li>Normal exit (voluntary).</li>\n<li>Error exit (voluntary).</li>\n<li>Fatal error (involuntary).</li>\n<li>Killed by another process (involuntary).</li>\n</ol>\n<p>Most process terminates because they have finished their job, in this case, a compiled program would have a system call to notify the OS.</p>\n<blockquote>\n<p>In linux, the system call is <code class=\"language-text\">exit</code>.</p>\n</blockquote>\n<p>In some systems (e.g., UNIX), a process can tell the operating system that it wishes to handle certain errors itself, in which case the process is signaled (interrupted) instead of terminated when one of the errors occurs.</p>\n<p>The fourth reason a process might terminate is that the process executes a system\ncall telling the operating system to kill some other process. In UNIX this call\nis <code class=\"language-text\">kill</code>.</p>\n<p>References</p>\n<ul>\n<li>Modern Operating Systems, Chapter 2 Process and threads</li>\n</ul>\n<h2>Process Hierarchies</h2>\n<p>In UNIX, a process and all of its children and further descendants together\nform a <strong>process group</strong>. When a user sends a signal from the keyboard, the signal is\ndelivered to all members of the process group currently associated with the\nkeyboard (usually all active processes that were created in the current window).\nIndividually, each process can catch the signal, ignore the signal, or take the default\naction, which is to be killed by the signal.</p>\n<p>UNIX initializes itself when it is started, just after the computer is booted.\nA special process, called <code class=\"language-text\">init</code>, is present in the boot image</p>\n<h2>Process Implementation</h2>\n<p>To implement the process model, the operating system maintains a table (an\narray of structures), called the <code class=\"language-text\">process table</code>, with one entry per process. (Some\nauthors call these entries <code class=\"language-text\">process control blocks</code>).</p>\n<blockquote>\n<p>In the Linux kernel, each process is represented by a <code class=\"language-text\">task_struct</code> in a doubly-linked list, the head of which is <code class=\"language-text\">init_task</code>.\nIn user mode, the process table is visible to normal users under <code class=\"language-text\">/proc</code> directory.</p>\n</blockquote>\n<h3>Zombie process</h3>\n<p>This is a concept for Unix-like systems. A process is a zombie process if it has completed execution (via <code class=\"language-text\">exit</code> system call) but still has an entry in the process table, in terminated states. The cause is that the parent process doesn't ignore nor handle the <code class=\"language-text\">SIGCHLD</code> signal.</p>\n<p>If the zombie process's parent exit, the zombie process will become orphan and adopt by the init process. Then it's entry can be cleared. However, in case of a long running parent process, zombie process entry can't be removed and will consume system resources.</p>\n<ol>\n<li>handle SIGCHLD properly</li>\n<li>fork twice and kill parent.</li>\n</ol>\n<h2>Scheduling</h2>\n<p>FCFS\nSJF</p>","frontmatter":{"title":"Process and thread"},"parent":{"__typename":"File","modifiedTime":"2021-10-26T14:41:02.019Z"}}},"pageContext":{}}}